#!/usr/bin/env ruby
# frozen_string_literal: true
# Runs containerized CI on a base image on DigitalOcean.

REQUIRED_OPTIONS = %i[
  ruby
].freeze

require "dotenv"
Dotenv.load(".env.local", ".env")
$LOAD_PATH.unshift File.expand_path(".", "lib")

# Parse command line options.
#
options = {}
require "optparse"
OptionParser.new { |parser|
  parser.banner = "Usage: example.rb [options]"

  parser.on("-eENVAR", "--env=ENVAR", "Set an envar") do |envar|
    (options[:env] ||= []) << envar
  end

  parser.on("-rRUBY", "--ruby=RUBY", "Ruby version to use") do |ruby|
    options[:ruby] = ruby
  end

  parser.on("-sSIZE", "--size=SIZE", "Droplet size (default: s-1vcpu-1gb)") do |size|
    options[:size] = size
  end

  parser.on("-h", "--help", "Prints this help") do
    puts parser
    exit
  end
}.parse!

# Validate command line options.
#
REQUIRED_OPTIONS.each do |required_option|
  fail "#{required_option} is a required argument" unless options.include?(required_option)
end

# Set default values for options.
#
options[:size] ||= "s-1vcpu-1gb"

# Make sure a command was passed.
#
fail "please pass a command to run" if ARGV.empty?

# Find the latest snapshot.
#
require "droplet_kit"
snapshot = DropletKit::Client.new(access_token: ENV["DIGITAL_OCEAN_KEY"]).snapshots.all.select { |s|
  s.name.start_with?("pakyow-ci")
}.sort_by(&:name).first

exit_code = exit_code
require "pakyow/ci/remote/system"

begin
  ephemeral_options = {
    name: "pakyow-ci-#{Time.now.to_i}",
    ssh_keys: [ENV["DIGITAL_OCEAN_SSH_FINGERPRINT"]],
    image: snapshot.id
  }

  puts "creating ephemeral server: #{ephemeral_options}"
  Pakyow::CI::Remote::System.new.ephemeral(**ephemeral_options) do |server|
    keys = [ENV["SSH_PRIVATE_KEY_PATH"]]
    puts "opening remote shell with keys: #{keys}"

    keys.each do |key|
      fail "missing key: #{key}" unless File.exist?(File.expand_path(key))
    end

    server.shell(keys: keys) do |shell|
      path_to_upload = File.expand_path(".")
      shell.upload path_to_upload
      shell.run "cd #{File.basename(path_to_upload)}; docker-compose build --build-arg ruby=#{options[:ruby]}"
      exit_code = shell.run "cd #{File.basename(path_to_upload)}; docker-compose run #{options[:env].to_a.map { |e| "-e #{e}"}.join(" ")} pakyow-ci '#{ARGV.join(" ")}'"
    end
  end
rescue => error
  puts <<~ERROR
    failed: #{error}
    #{error.backtrace.join("\n")}
  ERROR

  exit_code = 1
end

puts "exiting: #{exit_code}"
exit exit_code
